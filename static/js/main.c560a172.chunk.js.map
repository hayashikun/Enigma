{"version":3,"sources":["model/Enigma.ts","component/Encoder.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["AlphabetEnigma","_Enigma","rotorPositions","reflectorConfiguration","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","alphabet","length","inherits","createClass","key","value","str","chars","Array","from","_","k","charAt","toUpperCase","filter","s","indexOf","map","encryptChars","c","join","Enigma","numberOfChars","currentPosition","Error","char","_this","forEach","pos","idx","rotorPos","Math","floor","max","find","includes","p","reverse","rev_idx","_this2","encryptChar","Encoder","state","plain","encoded","encoderConfiguration","enigma","i","replace","setState","resetPosition","encodedStr","encryptAlphabetString","conf","encode","_this3","react_default","a","createElement","className","htmlFor","id","onChange","e","updateEncoderConfiguration","target","React","Component","App","component_Encoder","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c560a172.chunk.js","sourcesContent":["type Char = number;\n\nexport class Enigma {\n    rotorPositions: Char[];\n    currentPosition = 0;\n    reflectorConfiguration: Char[][];\n    numberOfChars: number;\n\n    constructor(rotorPositions: Char[], reflectorConfiguration: Char[][], numberOfChars: number) {\n        if (reflectorConfiguration.length !== numberOfChars && numberOfChars % 2 !== 0) {\n            throw Error();\n        }\n        this.rotorPositions = rotorPositions;\n        this.reflectorConfiguration = reflectorConfiguration;\n        this.numberOfChars = numberOfChars;\n    }\n\n    resetPosition(rotorPositions: Char[] | null) {\n        if (rotorPositions) {\n            if (this.rotorPositions.length !== rotorPositions.length) {\n                throw Error();\n            }\n            this.rotorPositions = rotorPositions;\n        }\n        this.currentPosition = 0;\n    }\n\n    encryptChar(char: Char): Char {\n        this.rotorPositions.forEach((pos, idx) => {\n            let rotorPos = pos + Math.floor(this.currentPosition / Math.max(this.numberOfChars * idx, 1));\n            char = char + rotorPos\n        });\n        char = char % this.numberOfChars;\n\n        char = this.reflectorConfiguration.find(s => s.includes(char))!.find(p => p !== char)!;\n        this.rotorPositions.reverse().forEach((pos, rev_idx) => {\n            let idx = this.rotorPositions.length - rev_idx - 1;\n            let rotorPos = pos + Math.floor(this.currentPosition / Math.max(this.numberOfChars * idx, 1));\n            char = char - rotorPos + this.numberOfChars;\n        });\n        char = char % this.numberOfChars;\n\n        this.currentPosition++;\n        return char;\n    }\n\n    encryptChars(chars: Char[]): Char[] {\n        return chars.map(c => this.encryptChar(c))\n    }\n}\n\nexport class AlphabetEnigma extends Enigma {\n    static readonly alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ_?\";\n\n    constructor(rotorPositions: Char[], reflectorConfiguration: Char[][]) {\n        super(rotorPositions, reflectorConfiguration, AlphabetEnigma.alphabet.length)\n    }\n\n    encryptAlphabetString(str: string): string {\n        let str_array = Array.from({length: str.length}, (_, k) => str.charAt(k).toUpperCase());\n        let chars = str_array\n            .filter(s => AlphabetEnigma.alphabet.indexOf(s) >= 0)\n            .map(s => AlphabetEnigma.alphabet.indexOf(s));\n        chars = this.encryptChars(chars);\n        return chars.map(c => AlphabetEnigma.alphabet.charAt(c)).join(\"\");\n    }\n}\n","import React from 'react';\nimport {AlphabetEnigma} from \"../model/Enigma\";\n\nclass Encoder extends React.Component {\n    state = {\n        plain: \"\",\n        encoded: \"\",\n        encoderConfiguration: [\"A\", \"A\", \"A\"],\n    };\n\n    enigma = new AlphabetEnigma([0, 0, 0],\n        Array.from({length: AlphabetEnigma.alphabet.length / 2},\n            (_, k) => k).map(i => [i, AlphabetEnigma.alphabet.length - 1 - i]));\n\n    chars = Array.from({length: AlphabetEnigma.alphabet.length},\n        (_, k) => AlphabetEnigma.alphabet.charAt(k));\n\n\n    encode(str: string) {\n        str = str.replace(\" \", \"_\");\n        str = Array.from({length: str.length},\n            (_, k) => str.charAt(k).toUpperCase()).filter(s => this.chars.indexOf(s) >= 0).join(\"\");\n        this.setState({plain: str});\n        this.enigma.resetPosition(this.state.encoderConfiguration.map(c => this.chars.indexOf(c)));\n        const encodedStr = this.enigma.encryptAlphabetString(str);\n        this.setState({encoded: encodedStr})\n    }\n\n    updateEncoderConfiguration(idx: number, char: string) {\n        let conf = this.state.encoderConfiguration;\n        if (char.length >= 2) {\n            char = char.charAt(1)\n        }\n        char = char.toUpperCase();\n        if (this.chars.indexOf(char) >= 0) {\n            conf[idx] = char;\n        }\n        this.setState({encoderConfiguration: conf});\n        this.encode(this.state.plain);\n    }\n\n    render() {\n        return (\n            <div className=\"Encoder\">\n                <h2>Encoder</h2>\n                <div>\n                    <div className={\"encoder-configurations\"}>\n                        <div className={\"encoder-configurations-title\"}>Configurations:</div>\n                        <div>\n                            <label htmlFor={\"R1-Configuration\"}>R1:</label>\n                            <input id={\"R1-Configuration\"} value={this.state.encoderConfiguration[0]}\n                                   onChange={e => this.updateEncoderConfiguration(0, e.target.value)}/>\n                            <label htmlFor={\"R2-Configuration\"}>R2:</label>\n                            <input id={\"R2-Configuration\"} value={this.state.encoderConfiguration[1]}\n                                   onChange={e => this.updateEncoderConfiguration(1, e.target.value)}/>\n                            <label htmlFor={\"R3-Configuration\"}>R3:</label>\n                            <input id={\"R3-Configuration\"} value={this.state.encoderConfiguration[2]}\n                                   onChange={e => this.updateEncoderConfiguration(2, e.target.value)}/>\n                        </div>\n\n                    </div>\n                    <div>\n                        <div className={\"encoder-input\"}>\n                            <label htmlFor={\"PlainInput\"}>Plain Text:</label>\n                            <input id={\"PlainInput\"} value={this.state.plain}\n                                   onChange={e => this.encode(e.target.value)}/>\n                        </div>\n                        <div className={\"encoder-output\"}>\n                            Output: <span className={\"encoder-output-text\"}>{this.state.encoded}</span>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default Encoder;\n","import React from 'react';\nimport './App.css';\nimport Encoder from \"./component/Encoder\"\n\nconst App: React.FC = () => (\n    <div className=\"App\">\n        <h1>Enigma</h1>\n        <Encoder/>\n    </div>\n);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n    onSuccess?: (registration: ServiceWorkerRegistration) => void;\n    onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(\n            (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n            window.location.href\n        );\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener('load', () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        'This web app is being served cache-first by a service ' +\n                        'worker. To learn more, visit https://bit.ly/CRA-PWA'\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === 'installed') {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                'New content is available and will be used when all ' +\n                                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log('Content is cached for offline use.');\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch(error => {\n            console.error('Error during service worker registration:', error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n        .then(response => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get('content-type');\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf('javascript') === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\n                'No internet connection found. App is running in offline mode.'\n            );\n        });\n}\n\nexport function unregister() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister();\n        });\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App/>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}